\input{tex-header.tex}

\title{PiratenID: Technische Dokumentation}

\begin{document}
\maketitle

\begin{abstract}Dieses Dokument beschreibt das PiratenID-System sowie das darin verwendete Protokoll.
Es ist relevant für Personen, die die PiratenID-Software nachvollziehen, analysieren, betreiben oder modifizieren wollen,
für Entwickler, welche einen eigenen Client programmieren möchten, sowie für technisch Interessierte, welche einen Blick hinter die Kulissen werfen möchten.
Gewöhnliche Nutzer des ID-Systems benötigen dieses Dokument nicht und sollten stattdessen die Anleitung für Nutzer\footnote{\url{https://id.piratenpartei.de/doc/idsystem-userdoc.pdf}} lesen.
Entwickler von Webanwendungen, die das PiratenID-System mittels fertiger Libraries nutzen möchten, müssen dieses Dokument nicht lesen,
können dies aber tun, um einen Einblick in Sicherheitsmaßnahmen bei Webanwendungen und ein besseres Verständnis des Systems zu erhalten.
Für Entwickler von Webanwendungen existiert eine separate Anleitung\footnote{\url{https://id.piratenpartei.de/doc/idsystem-devdoc.pdf}}, die die wichtigsten Punkte zusammenfasst.
\end{abstract}

\newpage

{
\small
\tableofcontents
}

\newpage

\section{Einführung}
Das PiratenID-System soll es Mitgliedern der Piratenpartei ermöglichen, ihren Mitgliedschaftsstatus gegenüber von Dritten betriebenen Webseiten nachzuweisen,
ohne dass Zugriff auf die Mitgliederdatenbank nötig ist und ohne mehr Daten als nötig offenlegen zu müssen.

An einem Authentifizierungsvorgang sind immer drei Parteien beteiligt: (1) Der Nutzer bzw. sein Browser, (2) der Server des ID-Systems und (3) die Webanwendung,
beispielsweise ein von Dritten betriebenes Forum oder Umfragetool.
Um Verwirrung zu vermeiden, wird der Begriff "`Client"' bei der Protokollbeschreibung nicht verwendet,
da dieser sowohl den Browser als auch die Webanwendung (Client des ID-Systems) bezeichnen könnte.
Die Parteien werden im Folgenden als ID-System, Browser und Webanwendung bezeichnet.


\section{Authentifizierung}
Statt eines ursprünglich geplaten Protokolls wird OpenID 2.0\footnote{\url{http://openid.net/specs/openid-authentication-2_0.html}} (mit gewissen Einschränkungen)
mit Attribute Exchange 1.0\footnote{\url{http://openid.net/specs/openid-attribute-exchange-1_0.html}} verwendet.
Die serverseitige Implementierung ist eine vollständige Eigenentwicklung, da die Libraries eine zu hohe Komplexität haben, um sie vollständig zu reviewen,
und eine kurze Durchsicht einiger Libraries Zweifel an der Sicherheit weckte.
\footnote{Beispiel: Die PHP-OpenID-Library von Janrain greift bei fehlendem curl auf fopen zurück, was SSL-Zertifikate nicht prüft.}
Dabei wurde nur ein Teil des Protokolls implementiert, wodurch viele potentielle Quellen für Fehler und Sicherheitslücken wegfallen.
Die Kompatibilität mit gängigen OpenID-Libraries bleibt gewahrt, bei der Verwendung solcher Libraries ist aber auf mögliche Sicherheitsprobleme zu achten.
Zur Übersicht über die Überlegungen zu anderen Protokollen wird hier auf das englischsprachige Dokument
"`Building an authentication system under strict real-world constraints"'
\footnote{\url{http://www.janschejbal.de/arbeiten/authenticationsystem11.pdf}} verwiesen.

Die Verwendung von OpenID statt einem eigenen Protokoll ermöglicht Kompatibilität mit bestehenden Anwendungen,
ist im Fall einer Kompromittierung des Servers weniger problematisch
(Sicherheit basiert auf SSL-Zertifikat, dieses kann separat z. B. auf einem Reverse-Proxy gelagert werden,
Revocation des Zertifikats möglich falls Clients auf Revocation prüfen, Angreifer müsste zusätzlich MitM "`in den Tiefen des Internets"' durchführen), 
macht es aber leichter, kaputte Implementierungen zu erstellen (z. B. unzureichende Zertifikatsprüfung)
und kann je nach Implementierung (Liste der akzeptierten Zertifikate/CAs) gegen kompromittierte/bösartige Zertifizierungsstellen (CAs) anfällig sein.

Sämtliche OpenID-Transaktionen finden ausschließlich über HTTPS statt.
Es ist darauf zu achten, dass Webanwendungen HTTPS korrekt einsetzen (z. B. Zertifikatsprüfung), da über die HTTPS-Verbindung die Daten des Benutzers übertragen werden.
Zur Erhöhung der Sicherheit sollen Webanwendungen zusätzlich den Fingerprint des Zertifikats prüfen, um gegen Angriffe auf Zertifizierungsstellen geschützt zu sein.
Associations werden nicht unterstützt, ebensowenig ein Fallback auf OpenID 1.1.

Webanwendungen, die gewöhnliche OpenID-Libraries einsetzen, müssen sicherstellen, dass Logins nur mit dem ID-System und nicht mit beliebigen fremden OpenID-Servern möglich sind.
Zusätzlich muss sichergestellt sein, dass die Library SSL korrekt nutzt und wenn irgendwie möglich nur das manuell eingepflegte Zertifikat des ID-Systems akzeptiert.

Bei der OpenID-Anfrage unterliegt das Realm einer recht strengen Prüfung, es muss sich um eine HTTPS-URL auf einen Ordner handeln, genauer:
Die URL muss mit einem Schrägstrich enden und darf keine Query-Parameter oder Anker enthalten.
Sowohl die anfragende Seite als auch die Return-URL müssen innerhalb dieses Realms liegen.
Das Realm wird zur Berechnung des Pseudonyms verwendet und dem Nutzer als der Name der Seite, bei der er sich anmeldet, angezeigt.


\subsection{Authentifizierungsmodi}
Bei der Authentifizierung über PiratenID werden mehrere Arten unterschieden.
Bei der OpenID-Anfrage kann das Feld claimed\_id/identity entweder auf die Konstante \verb@http://specs.openid.net/auth/2.0/identifier\_select@
für identifier\_select gestellt oder das Feld ganz weggelassen werden. (Andere Werte werden nicht akzeptiert.)
In ersterem Fall wird eine pseudonyme Anmeldung durchgeführt, d.h. das ID-System berechnet das seitenspezifische Pseudonym und übermittelt eine URL der Form\\
\verb@https://id.piratenpartei.de/openid/pseudonym.php?id=4e2b9b5163[...]faced7@\\
wobei der Teil nach "`id="' das Pseudonym ist.

In letzterem Fall wird eine anonyme Anmeldung durchgeführt:
Die Anwendung erfährt bestimmte Informationen über den Nutzer (z. B. die Tatsache, dass er Pirat ist), aber nichts, womit sie den Nutzer wiedererkennen könnte.
Dies könnte z. B. benutzt werden, um Zugang zu Informationen oder Diensten auf Piraten zu beschränken.
Sollen Doppelaccounts verhindert oder Benutzer wiedererkannt werden, muss die pseudonyme Anmeldung benutzt werden.

Unabhängig davon, ob die Anmeldung anonym oder pseudonym stattfindet, wird die Piratenmitgliedschaft des Nutzers entweder implizit oder explizit geprüft:
Wird das Attribut "`mitgliedschaft-bund"' \textbf{nicht} über Attribute Exchange (siehe nächter Abschnitt) abgefragt findet eine implizite Prüfung statt -- 
nur Piraten mit gültiger Mitgliedschaft (und korrekt eingetragenem Token) können sich anmelden, alle anderen bekommen nur eine Fehlermeldung.
Wird es jedoch explizit abgefragt, kann sich jeder anmelden und die Anwendung muss/kann Piraten und Nichtpiraten selbst trennen,
z. B. um ehemaligen Mitgliedern noch Zugriff auf ihre Accounts zu ermöglichen.

Wird mit einer gewöhnlichen OpenID-Library ohne besondere Optionen eine Authentifizierung durchgeführt, 
so findet eine \textbf{pseudonyme} Anmeldung mit \textbf{impliziter} Prüfung der Mitgliedschaft statt, was für die meisten Fälle die richtige Wahl ist.
Anwendungen, die OpenID bereits unterstützen, können so in der Regel mit minimalen Veränderungen (Beschränkung auf den PiratenID-Server, Zertifikate) direkt verwendet werden.

\subsection{Mitgliedschaftsattribute}
Folgende Attribute können über Attribute Exchange abgefragt werden:
\label{sec:attribute}
\begin{itemize}
\item mitgliedschaft-bund
\item mitgliedschaft-land
\item mitgliedschaft-bezirk
\item mitgliedschaft-kreis
\item mitgliedschaft-ort
\item stimmberechtigt
\end{itemize}

Dem Attribut "`mitgliedschaft-bund"' kommt hierbei eine besondere Bedeutung zu,
da abhängig davon ob es abgefragt wird oder nicht eine implizite oder explizite Prüfung der Mitgliedschaft erfolgt (siehe oben).

Die Attribute müssen mit genau diesen Namen als Alias abgefragt werden.
Als Attributtyp ist jeweils "`https://id.piratenpartei.de/openid/schema/NAME"' anzugeben, wobei NAME durch den Namen des Attributs zu ersetzen ist.

Ist ein Attribut in der Antwort leer, kann dies daran liegen, dass kein gültiges Token eingetragen oder der Wert unbekannt ist.
Um absichtlich leere Attributfelder zu kennzeichnen (z. B. Pirat ist in keinem Ortsverband) werden drei Bindestriche verwendet.

Das Feld "`mitgliedschaft-bund"' enthält bei Mitgliedern den Wert "`ja"',
die restlichen Attribute teilen mit, in welchen Untergliederungen der Nutzer Mitglied ist.

Das Feld "`stimmberechtigt"' gibt an, ob das Mitglied nach aktueller Satzung stimmberechtigt ist,
und kann die Werte "`ja"' (stimmberechtigt) "`nein"' (nicht stimmberechtigt) annehmen oder leer sein (Status unbekannt).

Die Verknüpfung des Useraccounts mit den zugehörigen Daten findet über das Token statt.
Die Betreiber des ID-Servers können einen Account also nicht einer bestimmten Person zuordnen,
da die Zuordnung zwischen Token und Person nur über die Mitgliederverwaltung möglich ist.


\subsection{Pseudonym}
\label{sec:pseudo}
Das Pseudonym ermöglicht es einer Webanwendung, einen Benutzer wiederzuerkennen.
Es handelt sich hierbei nicht um einen vom Nutzer gewählten Namen, sondern um einen berechneten Wert.
Das Pseudonym wird nicht als Attribut, sondern als Teil des Felds claimed\_identifier übermittelt.

Zu jedem Benutzer wird in der Datenbank ein Zufallswert gespeichert, das sogenannte Usersecret. 
Das Pseudonym ist ein SHA256-Hash über eine systemweite geheime Konstante (das Pseudonym-Secret), das Usersecret sowie das Realm aus dem OpenID-Request.
Ändert sich einer dieser Werte, ändert sich auch das Pseudonym.
Das Pseudonym ist somit für jede Kombination von Benutzer und Realm einmalig, d.h. ein Nutzer hat für jedes Realm ein anderes Pseudonym.
Das konstante Pseudonym-Secret wäre hierbei eigentlich nicht nötig, erhöht aber die Sicherheit:
Wenn ein Angreifer Lesezugriff auf die Datenbank erhält, kann er ohne das (außerhalb der Datenbank) gespeicherte Pseudonym-Secret nichts mit den Usersecrets anfangen.
Versuche, die Hashes zu brechen und aus dem Pseudonym auf das Usersecret zu schließen sind bereits aufgrund der Entropie des Usersecrets aussichtslos.
Ohne Kenntnis von User- und Pseudonymsecret ist es nicht möglich festzustellen, ob zwei Pseudonyme dem gleichen Nutzer gehören.

Es wird empfohlen, als zusätzliche Sicherheitsmaßnahme das Pseudonym bei der pseudonymen Anmeldung dem Nutzer nicht anzuzeigen und am Besten nur gehasht zu speichern.
Hierbei ist es egal, ob die gesamte URL oder nur das Pseudonym an sich gehasht wird.
Dadurch kann selbst ein Angreifer, der aus irgendeinem Grund Authentifizierungsvorgänge fälschen kann, nicht die Identität eines bestehenden Nutzers übernehmen,
wenn er das Pseudonym nicht anderweitig erfahren hat.

Mit Zugriff auf die Secrets ist eine Zuordnung eines Pseudonyms zu einem Account möglich.
Bei einer Accountlöschung wird das Usersecret vernichtet, womit die Zuordnung nicht mehr möglich ist.

\subsection{Personenbezogene Daten}
Auf Wunsch einiger Mitglieder wurde die Option vorgesehen, auch personenbezogene Daten über das ID-System bestätigen zu können.
Hierzu wurden die Attribute \texttt{realname} und \texttt{mitgliedsnummer} sowie entsprechende Datenbankfelder reserviert.

Über ein zweites Token ("`B-Teil"') könnten diese Werte nach einem noch festzulegenden Verfahren
nach ausdrücklicher und freiwilliger Zustimmung des Mitglieds aus der Mitgliederverwaltung nachgetragen werden.
Der Zugriff auf diese Attribute ist derzeit vollständig deaktiviert.
Nach der Aktivierung ist eine Whitelist vorgesehen, d.h. nur gesondert freigeschaltete Realms hätten die Möglichkeit, diese Daten anzufordern.
Diese Freischaltung würde nur für Webanwendungen erfolgen, die die Daten zwingend brauchen und strenge Datenschutzvorschriften einhalten.
Wie alle Attribute werden diese Informationen nur nach ausdrücklicher Zustimmung des Nutzers an einen Dienst herausgegeben.

Die Möglichkeit, diese Daten zu speichern, wird nicht aktiviert, bevor ein entsprechender Bedarf vorliegt, d.h. eine Anwendung existiert die diese Daten zwingend benötigt.
Für die meisten Webanwendungen sind diese Daten nicht erforderlich.

Der Großteil der IT möchte diese Daten \textbf{nicht} im System haben.


\newpage
\section{Sicherheitseigenschaften}
In diesem Abschnitt werden Sicherheitseigenschaften des Systems aufgelistet, sowie die Maßnahmen genannt, die diese Eigenschaften sicherstellen.

\subsection{Nicht geplante Sicherheitseigenschaften}
Bevor auf die Sicherheitseigenschaften des Systems eingegangen wird, sollte erwähnt werden, welche möglichen Erwartungen an das System \textbf{nicht} erfüllt werden.
Die Liste kann logischerweise nie vollständig sein, sollte aber die wichtigsten Punkte umfassen.

\subsubsection{Absolute Sicherheit der Accounts}
Wie bei Onlinediensten üblich kann unter Angabe der E-Mail-Adresse eine Mail mit einem Kennwortrücksetzlink angefordert werden.
Ist ein Angreifer in der Lage, diese Mail mitzulesen, beispielsweise indem er den SMTP-Datenverkehr abhört oder Zugang zum E-Mail-Postfach des Nutzers hat,
kann er sich Zugang zum betroffenen Benutzerkonto verschaffen.

Dieses Risiko wird akzeptiert, da die Einschränkung der Nutzbarkeit ohne eine solche Funktion zu hoch wäre und es sich um ein allgemein übliches Verfahren handelt.
Angriffe, die auf dem Abhören der Mail bis zur Einlieferung ins Postfach des Empfängers beruhen, sind sehr selten.
Nutzer werden besonders darauf aufmerksam gemacht, dass sie den Zugang zu ihrem Postfach schützen müssen.

\subsubsection{Verwendete Mailadressen}
Da pro E-Mail-Adresse nur ein Benutzerkonto erstellt werden kann, kann beim Versuch einen Account anzulegen anhand der Fehlermeldung festgestellt werden,
ob mit der angegebenen Adresse bereits ein Benutzerkonto existiert.
Es wäre zwar möglich, dies zu verhindern, indem bei bereits verwendeter Adresse auch eine Erfolgsmeldung angezeigt wird und der Nutzer per Mail benachrichtigt wird.
Dies würde weiterhin erfordern, dass beim Zurücksetzen vergessener Kennwörter der Nutzer kein Feedback bekommt, wenn er eine falsche Adresse eingegben hat.
Eine solche Regelung wäre für den Nutzer verwirrend, und würde unter Umständen keine vollständige Sicherheit bieten (Seitenkanalangriffe).

Die Möglichkeit festzustellen, dass eine Adresse verwendet wird, wird daher akzeptiert,
was im Übrigen auch gängige Praxis
\footnote{getestet: wordpress.com (Passwortreset), drupal.org (Accounterstellung), phpbb.com (Accounterstellung im Supportforum), news.piratenpartei.de (Accounterstellung)}
ist.

\subsubsection{Schutz vor Betreiber}
Das System ist ein zentralisiertes Authentifizierungssystem.
Die Sicherheit beruht auf der Annahme, dass der Betreiber des Systems vertrauenswürdig ist.
Der Betreiber kann beliebige OpenID-Antworten liefern und hat somit die Möglichkeit, sich mit fremden oder falschen Attributen bei Diensten zu identifizieren.
Der ID-Server sieht bei jedem Login-Vorgang, welcher Nutzer sich wann bei welchem Dienst angemeldet hat.
Mit den Daten des ID-Servers können mit realistischem Aufwand Pseudonyme zu Nutzerkonten zugeordnet werden, solange das Usersecret nicht gelöscht wurde.

\subsubsection{Fehler beim Nutzer}
Das ID-System nutzt gewöhnliche Passwortauthentifizierung.
Wenn ein Nutzer ein unsicheres Passwort wählt oder es nicht geheim hält, kann jemand der dieses Passwort errät oder erlangt den Account missbrauchen.
Schadsoftware auf dem Rechner eines Nutzers kann das Kennwort ausspähen und den Account dieses Nutzers missbrauchen.
Das ID-System kann dem Nutzer die Pflicht nicht abnehmen, sich um seine Sicherheit zu kümmen. Hinweise auf Sicherheitsmaßnahmen werden jedoch gegeben.
Passwortrichtlinien (min. 8 Zeichen, min. 2 Arten von Zeichen) sind vorhanden.

Der Nutzer wird von fremden (d.h. potentiell bösartigen) Seiten auf die Seite des ID-Systems geleitet, wo er sich anmelden soll.
Der Nutzer muss selbst prüfen, dass er sich auf der richtigen Seite befindet.
Tut er dies nicht und gibt seine Nutzerdaten auf einer gefälschten Seite ein, können diese missbraucht werden.
Entsprechende Hinweise werden auf der Seite eingeblendet.

Client-Zertifikate werden nicht genutzt, da die Mehrzahl der Nutzer mit der korrekten Nutzung (Backup, Transfer auf andere Geräte) überfordert sein dürfte.
Außerdem würde es den Nutzern die Möglichkeit nehmen, sich von beliebigen Computern anzumelden, was von den Nutzern nicht akzeptiert würde.

\subsubsection{Sicherheitslücken in Webanwendungen}
Das ID-System schützt nicht vor Sicherheitslücken in den Webanwendungen.
Ist eine Webanwendung unsicher, kann sie die Daten ihrer Nutzer offenlegen oder Missbrauch der Anwendung zulassen.
Für die Entwickler von Webanwendungen steht ein Leitfaden zur Verfügung, der auch Sicherheitsthemen beinhaltet.
Die Entwickler sind für die Sicherheit der Anwendungen jedoch selbst verantwortlich.

\subsection{Vorgesehene Sicherheitseigenschaften}
\subsubsection{Sicherheit der Authentifizierung}
Bei korreter Anwendung des Protokolls soll sich die Webanwendung darauf verlassen können,
dass genau der Nutzer, zu dem die übermittelten Daten gehören, sich gegenüber dem ID-System eingeloggt hat,
sowie dass diese Daten korrekt sind.
Daraus folgt auch, dass es keinem Dritten möglich sein darf, sich mit einem fremden Pseudonym gegenüber einer Webanwendung auszuweisen.

Die Prüfung der Antwort beim ID-Server im Rahmen des OpenID-Protokolls stellt sicher, dass nur unverfälschte Antworten, die vom ID-System erstellt wurden, akzeptiert werden.
Replay-Attacken werden verhindert, da die Korrektheit einer Antwort nur einmal bestätigt wird.
Die Übermittlung per HTTPS verhindert das Mitlesen der Antworten.

Man-in-the-Middle-Attacken, bei denen eine Webanwendung die Login-Antwort eines Nutzers missbraucht,
um sich als dieser Nutzer an einer anderen Anwendung anzumelden, werden ebenfalls verhindert,
da die Return-URL im Rahmen des OpenID-Protokolls geprüft wird.

\subsubsection{Vertraulichkeit der Daten}
Die freigegebenen Daten werden nur an den angegebenen Dienst herausgegeben.
Dies wird sichergestellt, indem die Seite (Realm), an die die Daten weitergegeben werden sollen, angezeigt wird,
und die Return-URL (an die die Daten gesendet werden) zu diesem Realm gehören muss.
Die Übertragung der Daten findet SSL-gesichert statt, sodass Dritte nicht mitlesen können.

Der Dienst, der die Daten erhält, kann technisch nicht daran gehindert werden, diese Daten zu missbrauchen oder weiterzugeben.
Der Nutzer muss selbst entscheiden, ob er einem Dienst seine Daten anvertrauen möchte.

\subsubsection{Datenweitergabe nur mit Einverständnis}
Im ID-System gespeicherte Daten werden nur mit Einverständnis des Nutzers, bestätigt durch die Eingabe des Kennworts, weitergegeben.

\subsubsection{Ein Pirat -- ein Pseudonym (pro Realm)}
Jeder Nutzer hat nur ein Pseudonym pro Realm.
Eine Webanwendung, die Umfragen oder Abstimmungen anbietet, kann sich daher in der Regel darauf verlassen, dass jedes Mitglied nur einmal teilnehmen kann,
wenn pro Pseudonym nur eine Teilnahme ermöglicht wird und die Mitgliedseigenschaft geprüft wird.

Aus diesem Grund ist es einem Teilnehmer auch nicht möglich, sein Pseudonym zu ändern, allerdings kann jeder mehrere Benutzerkonten haben.
Die Bindung eines Kontos an eine Person geschieht erst durch die Eingabe eines Tokens -- ohne Token ist das Konto nicht als das Konto eines Mitglieds bestätigt.
Um sicherzustellen, dass ein Mitglied (in seiner Eigenschaft als Mitglied) nicht mehrere Konten (und somit mehrere Pseudonyme nutzt),
wird bei der Eingabe eines Tokens dieses an das entsprechende Konto gebunden.

Ein einmal eingegebenes Token kann nicht mehr entfernt oder geändert werden, und es ist nicht möglich, das gleiche Token für ein anderes Konto zu verwenden.
Wird ein Benutzerkonto gelöscht, bleibt das Token (bzw. ein Hash davon) gespeichert, um sicherzustellen, dass es nicht wiederverwendet werden kann
(ein neues Konto hätte ein anderes Usersecret und somit andere Pseudonyme).

Da mit der Löschung eines Kontos bis auf das Token alle Daten (inkl. Usersecret) gelöscht werden, und ein Token nicht wiederverwendet werden kann,
bedeutet dies, dass ein Mitglied, welches sein Konto mit eingetragenem Token löscht, das ID-System nicht mehr benutzen kann.
Die Mitgliederverwaltung darf in diesem Fall \textbf{kein} neues Token ausstellen, da das Prinzip "`Ein Pirat -- ein Pseudonym"' damit verletzt würde!

Nicht verwendete Token können beliebig ausgetauscht werden. Vor der Neuausstellung eines Tokens sollte die Mitgliederverwaltung bestätigen lassen,
dass das alte Token nicht verwendet wurde, und dieses sperren lassen.
Sollte ein Austausch verwendeter Token gewünscht sein, muss entweder die Verletzung dieses Prinzips im Einzelfall in Kauf genommen werden,
oder es muss ein weiteres Attribut "`token-index"' eingeführt werden, durch welches Webanwendungen gegenüber angezeigt wird, ob ein Token neu ausgestellt wurde.
Webanwendungen könnten somit selbst entscheiden, ob bzw. bis zu wie viele Neuausstellungen (d.h. Pseudonymänderungen) sie pro Mitglied zulassen.


\subsubsection{Nichtverknüpfbarkeit der Pseudonyme}
Es soll Dritten nicht möglich sein, Pseudonyme mit dem Benutzerkonto oder mit anderen Pseudonymen zu verknüpfen,
d.h. es soll auch zusammenarbeitenden Diensteanbietern (mit verschiedenen Domains/Realms) nicht möglich sein festzustellen, 
dass ein Pseudonym zu einem bestimmten Benutzerkonto gehört oder dass
Pseudonym 1 in der ersten Webanwendung und Pseudonym 2 in der zweiten Webanwendung dem gleichen Nutzer gehören.
Dies wird durch das Berechnungsverfahren für Pseudonyme (siehe entsprechender Abschnitt) sichergestellt.


\subsection{Vermutete Sicherheitseigenschaften}
Die im folgenden benannten Eigenschaften sind während der Entwicklung "`nebenbei"' entstanden und wurden nicht vollständig überprüft.
Es handelt sich um zusätzliche Eigenschaften die keineswegs für einen sicheren Betrieb nötig sind, jedoch die Sicherheit erhöhen können
(Defence in depth) oder technisch interessant sind.

\subsubsection{Stärke gegen Angreifer mit Datenbankzugriff}
Ein Angreifer, der Lesezugriff auf die (gegen solchen Zugriff selbstverständlich geschützte) Datenbank erlangt,
kann zwar die Nutzerdatenbank auslesen, aber nicht am System missbrauchen.
Insbesondere sollte es nicht möglich sein, ein benutzbares Token zu erhalten (da die Token gehasht gespeichert werden, aber im Klartext eingegeben werden müssen),
ein Benutzerkonto zu nutzen/übernehmen (da die Passwörter gehasht gespeichert werden),
ein Kennwort zurückzusetzen (Reset-Keys werden gehasht gespeichert) oder
eine falsche E-Mail-Adresse zu bestätigen (Bestätigungskeys werden gehasht gespeichert).
Auch bei einem unsicheren Kennwort sollte der Angreifer keine Möglichkeit haben, den Passworthash zu Bruteforcen,
da ein zusätzliches, in den Systemkonstanten gespeichertes geheimes Salt verwendet wird.
(Die Möglichkeit einer langsamen und somit nur gegen sehr schwache Kennwörter möglichen Online-Bruteforce-Attacke bleibt unverändert.)

Auch das Zuordnen von Pseudonymen sollte unmöglich sein, da das zusätzlich verwendete Pseudonym-Secret unbekannt ist.

\subsubsection{Stärke gegen Angreifer mit Dateisystemzugriff}
Ein Angreifer, der Lesezugriff auf das Dateisystem erlangt, könnte in der Lage sein, den privaten Schlüssel für das SSL-Zertifikat zu erlangen,
sofern dieser auf dem System gespeichert ist.
Damit könnte er Antworten fälschen, wenn es ihm gelingt, die Echtheitsanfrage der Webanwendung an den ID-Server auf sein System umzuleiten.
Ohne vorherige Kenntnis des Pseudonyms kann er dieses nur berechnen (und darüber Pseudonyme zuordnen),
wenn er auch Zugriff auf die Datenbank (oder die Dateien in der die Datenbanktabellen liegen) hat.
Ohne Kenntnis des Pseudonyms kann er gegenüber Webanwendungen nicht vortäuschen, ein bestimmter anderer Nutzer zu sein.
Benutzerkonten mit sicheren Kennwörtern sollten weiterhin wie beim Angreifer mit Datenbankzugriff geschützt sein.


\newpage
\section{Schutzmaßnahmen gegen Angriffe}
\subsection{Server}
\subsubsection{Schwachstelle Mensch}
Um Angriffe, die Fehler des Nutzers ausnutzen, zu erschweren, werden die Nutzer durch gut sichtbare Banner auf wichtige Sicherheitsmaßnahmen hingewiesen.
Dazu zählt die sichere Verwendung von HTTPS, Sicherheit des verwendeten Computers, Passwortsicherheit, sowie die Absicherung des E-Mail-Accounts.

\subsubsection{Brute-Force-Angriffe}
Um Brute-Force-Angriffe zu verhindern, werden aufgrund falscher Logindaten fehlgeschlagene Loginversuche protokolliert.
Vor jedem Login wird geprüft, wie viele Einträge zu der entsprechenden IP bereits existieren.
Sind mehr als 3 Fehlversuche protokolliert, wird das Login abgelehnt (IP-Sperre).

Die protokollierten Fehlversuche werden im Rahmen des Datenbank-Cleanups beim Öffnen der Datenbankverbindung jeweils nach 30 Minuten gelöscht.
Die IP ist also genau dann gesperrt, wenn es von ihr innerhalb der letzten 30 Minuten drei Fehlversuche gab,
nicht z. B. 30 Minuten nach dem letzten Versuch.

\subsubsection{Cross-site request forgery, Session-basierte Angriffe}
Der Server des ID-Systems arbeitet vollständig ohne Sessions. CSRF sowie andere Session-basierte Angriffe sind somit nicht möglich.
Der Nutzer muss zur Bestätigung von Transaktionen jedes mal seine Logindaten eingeben.
Der Zugriff auf Nutzerdaten wird wo möglich über einer Funktion gekapselt, die die Logindaten prüft, um Programmierfehler auszuschließen.

Mittels CSRF-Versuchen auf die Login-Funktion wäre es jedoch möglich, die IP des Nutzers für Brute-Force-Versuche zu nutzen
und/oder den Brute-Force-Schutz auszulösen und den Nutzer so temporär auszusperren.
Um das zu erschweren, wird bei Loginversuchen der Referer geprüft.
Stammt dieser nicht vom ID-System, wird der Loginversuch abgelehnt, ohne ihn zu zählen.
Wenn der Nutzer einen leeren Referer überträgt (Referer abgeschaltet/gefiltert), wird die Refererprüfung übersprungen,
damit auch Nutzer mit aus Datenschutzgründen gefilterten Referern sich einloggen können.

Diese Überprüfung bietet keinen vollständigen Schutz.
Falls entsprechende Angriffe beobachtet werden, muss der Schutz auf Kosten der Nutzerfreundlichkeit erhöht werden,
indem leere Referer zurückgewiesen werden und/oder ein Cookie-basiertes Token verwendet wird.

\subsubsection{SQL-Injection/Truncation}
Zum Schutz vor SQL-Injection werden Prepared Statements benutzt.
Um Truncation-Angriffe zu verhindern, wird an mehreren Stellen die Länge von Parametern geprüft
und die Datenbankverbindung so konfiguriert (SQL mode), dass auch leichte Fehler (z. B. überlange Felder) als fatale Fehler behandelt werden.

\subsubsection{Passwort-Hashverfahren}
\label{sec:pwhash}
Kennwörter werden nicht im Klartext, sondern mit SHA256 gehasht gespeichert.
Dabei werden der Benutzername als Salt, ein zusätzliches systemspezifisches Salt und strengthening als zusätzlicher Schutz eingesetzt.

Das bedeutet, dass ein Angreifer, der die Datenbank erlangt, zwar prüfen kann, ob ein Benutzer ein bestimmtes Kennwort hat,
die Kennwörter aber nicht entschlüsseln kann.
Der gängige Angriff gegen derart gesicherte Passwörter ist es, jedes Wort aus einer Liste (Wörterbuch, alle Buchstabenkombinationen, ...)
gegen die Liste zu prüfen, um so Treffer zu finden und Kennwörter aufzudecken (Brute-Force/Dictionary attack).

Um solche Angriffe zu erschweren, werden die Hashes folgendermaßen gebildet:
\begin{enumerate}
	\item Das Kennwort wird mit dem Benutzernamen (benutzerspezifisches Salt) und einer geheimen Systemkonstante (Systemsalt) verkettet und gehasht
	\item Der aktuelle Hash wird verkettet mit einem Zähler und dem ersten Hash, und erneut gehasht (das Ergebnis wird der neue aktuelle Hash).
	\item Dieser Schritt wird für viele Iterationen wiederholt (der Zähler wird jeweils hochgezählt)
\end{enumerate}

Die Salts sorgen dafür, dass das gleiche Kennwort bei zwei unterschiedlichen Nutzern oder auf zwei verschiedenen Systemen unterschiedliche Hashes ergibt.
Das geheime Systemsalt macht Brute-Force-Angriffe gegen die Hashes völlig unmöglich, solange der Angreifer es nicht erlangt.
Die Verkettung und Verwendung des Zählers stellt sicher, dass jede Iteration anders ist und verhindert so, dass das Verfahren in einen Zyklus gerät.

Durch die Verwendung der Salts wird die Verwendung vorausberechneter Rainbow Tables zur Beschleunigung von Angriffen unmöglich.
Um ein Kennwort auf Gültigkeit zu testen, müssen zahlreiche Hashes (Iterationen) berechnet werden, was einige Millisekunden dauert.
Dadurch werden Brute-Force-Versuche so stark ausgebremst, dass sie unpraktisch werden.

Anzumerken ist, dass diese Schutzmaßnahmen nur für den unwahrscheinlichen Fall benötigt werden, dass es einem Angreifer gelingt, die Benutzerdatenbank zu kopieren.
Da die Verlangsamung durch das strengthening auch auf den Server selbst zutrifft,
wird bei Online-Brute-Force-Versuchen die Geschwindigkeit durch die CPU-Leistung des Servers selbst dann wirksam begrenzt,
wenn andere Schutzmaßnahmen versagen.

\subsubsection{Hashing}
Auch andere Informationen werden wo möglich nur gehasht gespeichert,
beispielsweise die Token und die zum Zurücksetzen von Passwörtern und Bestätigen von Mailadressen nötigen Keys.

\subsubsection{Clickjacking-Schutzmaßnahmen}
Bei webbasierten Diensten besteht die Gefahr des sogenannten Clickjackings.
Hierbei wird die angegriffene Website (hier: das ID-System) unsichtbar eingebunden, und der Nutzer dazu gebracht, eine (sichtbare) Schaltfläche zu drücken.
Der Klick auf die Schaltfläche trifft jedoch durch geschickte Anordnung der Elemente die angegriffene Webseite und löst dort eine Aktion aus.
Im Fall des ID-Systems könnte dies z. B. die Bestätigung der Datenfreigabe sein.

Auch der Zwang, zu jeder Aktion das Kennwort eingeben zu müssen, schützt nicht vor diesem Angriff, da viele Browser Kennwörter speichern und automatisch ausfüllen.
Um diesen Angriff zu verhindern, werden drei Schutzmaßnahmen getroffen:

Ein entsprechender HTTP-Header (\texttt{X-Frame-Options: deny}) verhindert in modernen Browsern die Einbettung.
Dies ist insbesondere deswegen wichtig, in modernen Browsern IFRAME-Attribute (z. B. \texttt{sandbox}) den Javascript-basierten Schutz aushebeln.

Nutzer ohne JavaScript müssen beim Login zufällige Ziffern abtippen, welche als ausformulierte Wörter mit zufälliger Position auf der Seite stehen.
Da bei Clickjacking die einbettende Seite nicht auf den Inhalt der eingebetteten Seite zugreifen kann, verhindert dies den Angriff weitgehend.
Die zufällige Positionierung verhindert, dass dieser Teil der Website sichtbar belassen und nur der Rest überdeckt wird.
Das Ausschreiben als Wort verhindert, dass der Nutzer dazu gebracht wird, die Ziffern zu markieren und ins Zielfeld zu ziehen.
Da sowohl vor als auch nach den Ziffern ein zufälliger Abstand eingefügt wird, kann ein Angriff auch aus der Länge der Webseite nicht die korrekte Position errechnen.

Bei aktivem JavaScript wird eine Einbettung erkannt und in einem solchen Fall eine Warnung angezeigt sowie die Seite des ID-Systems verborgen.

\subsubsection{Sichere Zufallszahlen}
Zufallszahlen, bei denen ein hohes Sicherheitsniveau erforderlich ist, werden über OpenSSL generiert, statt sich auf unsichere PHP-Methoden zu verlassen.
Dadurch ist die hohe Qualität und Nichtvorhersagbarkeit der Zufallszahlen sichergestellt.

\subsubsection{HTTPS}
Sämtliche Kommunikation mit dem ID-System erfolgt über HTTPS.
Die Nutzer werden darauf hingewiesen, immer die vollständige URL inkl. "`https"' zu verwenden.
Um Nutzer zu schützen, welche die Adresse trotzdem mit "`http"' statt "`https"' eingeben, wird der \texttt{Strict-Transport-Security}-Header genutzt.
Dieser weist moderne Browser an, die Seite ausschließlich über HTTPS abzurufen und verhindert so,
dass Nutzer es über HTTP versuchen und sich so der Gefahr von MitM-Attacken aussetzen.

\subsubsection{Internet Explorer 6}
Nutzer des Internet Explorer 6 und früher werden von der Nutzung des ID-Systems ausgeschlossen und darauf hingewiesen, dass sie ihr System aktualisieren sollen.
Mit dem IE6 ist eine sichere Internetnutzung nicht möglich, zudem deutet sein Vorhandensein auch auf ein generell veraltetes (und somit unsicheres) System hin.



\subsection{Client}
\label{sec:security-client}
Der speziell entwickelte PHP-Client für PiratenID enthält einige erwähnenswerte Schutzmaßnahmen:

\subsubsection{Schutz vor Session fixation}
Es wird versucht, den php.ini-Wert \texttt{session.use\_only\_cookies} zu setzen.
Gelingt dies, werden session fixation-Versuche beim Start der Session ignoriert.
Scheitert dies, wird nach jedem Start/Fortsetzen der Session eine neue Session-ID erstellt, um Angriffe zu verhindern.
Dadurch kann die Stabilität der Sessions beeinträchtigt werden.

Da jedoch nicht ausgeschlossen werden kann, dass andere Skripte auf dem Server session fixation zulassen,
wird die Sitzungs-ID auch neu generiert, wenn die Sitzung bereits gestartet war,
oder wenn sie zum ersten Mal von PiratenID genutzt wird.

Dadurch wird sichergestellt, dass eine dem Angreifer dank session fixation bekannte Session-ID ungültig wird,
bevor Daten bzw. ein Loginzustand von PiratenID in der Sitzung gespeichert werden.

\subsubsection{Sicherheit des Session-Cookies}
Die Gültigkeit des Session-Cookies wird beschränkt auf das eingestellte OpenID-Realm.
Dadurch wird in Szenarien, wo mehrere Anwendungen sich eine Domain teilen, sichergestellt,
dass Skripte außerhalb des Realms nicht an die Session-ID gelangen.

Das Session-Cookie wird weiterhin so eingestellt, dass es lediglich über HTTPS-gesicherte Verbindungen verschickt wird.
Dies verhindert, dass die Session-ID z. B. durch unsicher eingebundene Bilddateien unverschlüsselt übertragen wird.
Eine weitere Option, die aktiviert wird, verhindert das Auslesen das Cookies durch JavaScript (was z. B. XSS-Angriffe erschwert).

\subsubsection{Parameterprüfungen, Selbstschutz}
Die Library schützt sich gegen irrtümlich falsche Benutzung,
z. B. indem die Einbindung auf Seiten, die nicht über HTTPS aufgerufen werden, verhindert wird.
Gegen absichtlichen Missbrauch ist die Library nicht geschützt, da jeder, der die Library missbrauchen möchte, einfach den Code ändern kann.

\subsubsection{Anleitung}
Webanwendungsentwickler erhalten eine Anleitung, welche neben der korrekten Verwendung der PiratenID-Library auch allgemeine Sicherheit von Webanwendungen behandelt.


\newpage
\section{Installation/Deployment des Servers}
Der Server benötigt ein aktuelles PHP (getestet mit PHP 5.3.3), eine MySQL5-Datenbank sowie einen HTTPS-fähigen Webserver.

Um den Server zu installieren, müssen folgende Schritte durchgeführt werden:

\subsection{Datenbank einrichten}
Eine MySQL-Datenbank muss erstellt werden.
In diese Datenbank wird die Datenbankstruktur aus database.sql.txt (im Verzeichnis /doc/tech/) importiert.
Es sollte ein separater Benutzer für die Nutzung durch den PiratenID-Server angelegt werden.
Dieser sollte ausschließlich auf die eigene Datenbank zugreifen dürfen.
Es reichen Rechte für SELECT, INSERT, UPDATE und DELETE. Für die Tabelle "`tokens"' sind Leserechte ausreichend.
Der MySQL-Server sollte \textbf{nicht} von außen erreichbar sein.

\subsection{Dateien installieren}
Die Dateien des Servers (im Repository unter /server/) werden in das Webroot des Servers/VHosts gelegt.
Die Dokumentation (aus den Unterverzeichnissen von /doc/ im Repository) muss mit pdflatex (mehrere Durchläufe nötig!) kompiliert werden.
Die resultierenden PDF-Dateien kommen im Webroot nach doc/.
Die Linux-Zugriffsrechte sollten möglichst restriktiv gesetzt werden.

\subsection{Konfiguration}
Die Datei siteconstants.EXAMPLE.inc.php nach siteconstants.inc.php kopieren und den Inhalt anpassen (insbesondere neue Secrets vergeben).
Die Datei muss gegen unbefugten Zugriff gesichert und durch Backups vor Verlust geschützt werden. Ohne die dort eingestellten Secrets ist die Datenbank unbrauchbar!
Es kann sinnvoll sein, die Datei read-only zu setzen.

Der Server sollte ausschließlich per HTTPS erreichbar sein.
Das "`includes"'-Verzeichnis sollte gegen Zugriff von außen geschützt sein.
Beim Einsatz von nginx wird die .htaccess-Datei ignoriert, sodass eine entsprechende deny-Regel in der Konfigurationsdatei nötig wird!
Beispielsweise kann folgende Zeile \textbf{vor} die PHP-Konfiguration eingefügt werden:
\begin{verbatim}
    location ~ ^/includes/ { deny all; }
\end{verbatim}


\subsection{Import der Token}
Die Liste der Token und zugehörigen Daten muss regelmäßig importiert werden.

TODO Importverfahren sobald es feststeht

\newpage
\section{Dateien des Servers}

\subsection{Verzeichnis /includes/}
Dieses Verzeichnis enthält Dateien, die von den anderen Skripten eingebunden werden.

\subsubsection{/includes/header.inc.php}
Diese Datei enthält den Anfang jeder ausgegebenen HTML-Seite.
Sie liefert das HTML-Grundgerüst der Seite mit Sicherheitshinweisen, Menü und IE6-Blocker aus.
Falls die globale Variable \texttt{\$PAGETITLE} gesetzt ist, wird deren Wert mit in das title-Tag aufgenommen.
Technische Einstellungen wie HTTP-Header werden von der Datei techheader.inc.php vorgenommen, welche inkludiert wird.


\subsubsection{/includes/techheader.inc.php}
Diese Datei nimmt technische Einstellungen vor und wird (direkt oder indirekt) von jedem PHP-Skript (also auch von denen, die kein HTML generieren) inkludiert.

\begin{itemize}
	\item Ein Error-Handler, der Fehler wie Warnungen zu fatalen Fehlern macht und wenig Informationen über den Fehler mitteilt, wird aktiviert.
	\item Es wird sichergestellt, dass \texttt{register\_globals} deaktiviert ist.
	\item \texttt{siteconstants.inc.php} und \texttt{functions-global.inc.php} werden eingebunden.
	\item Die HTTP-Header \texttt{X-Frame-Options}, \texttt{Strict-Transport-Security} und \texttt{X-XRDS-Location} werden gesetzt.
\end{itemize}

\subsubsection{/includes/footer.inc.php}
Diese Datei enthält das Ende jeder ausgegebenen HTML-Seite:
\begin{itemize}
	\item Der IE6-Blocker und das maincontent-DIV werden geschlossen
	\item Die Fußzeile wird ausgegeben
	\item Der JavaScript-basierte Clickjacking-Schutz wird ausgegeben
\end{itemize}

\subsubsection{/includes/siteconstants.inc.php}
Diese Datei enthält (z.T. geheime!) Konstanten, die bei der Installation des Servers gesetzt werden müssen:
\begin{itemize}
	\item \texttt{\$sitepath} -- Die absolute Adresse des ID-Systems. Wird z. B. beim Versand von E-Mails verwendet.
	\item \texttt{\$extendedAttributeRealms} -- Die Liste der Realms, die erweiterte Attribute (Realname, Mitgliedsnummer) anfragen können.
	\item \texttt{getDatabasePDO()} -- Hier werden die Datenbank-Zugangsdaten eingetragen
	\item \texttt{\$pseudonymsecret} -- Ein zusätzliches Salt zur Berechnung der Pseudonyme, siehe Abschnitt \fullref{sec:pseudo}.
	\item \texttt{\$passwordsaltsecret} -- Ein zusätzliches Salt zur Berechnung der Passwort-Hashes, siehe Abschnitt \fullref{sec:pwhash}.
	\item \texttt{\$openid\_hmacsecret} -- Das zur Berechnung der OpenID-Signaturen verwendete secret. 
\end{itemize}
Maßnahmen, die zu treffen sind, wenn eine der geheimen Konstanten kompromittiert wird, sind in der Datei selbst dokumentiert.


\subsubsection{/includes/functions-global.inc.php}
Diese Datei enthält die globalen Funktionen:
\begin{itemize}
	\item \texttt{safeout(\&\$text)} -- Gibt eine Variable mit korrektem HTML-Escaping aus. Ist die Variable undefiniert, wird nichts ausgegeben, aber keine Warnung erzeugt
	\item \texttt{prefilter(...)} -- Prüft einen Wert (z. B. GET/POST-Parameter) auf Existenz, Typ und Länge
	\item \texttt{logPrefilter(...)} -- Bereitet einen Wert für die Speicherung im loginfailures\_log vor.
	\item \texttt{generateNonce(\$entropy)} -- Erzeugt die angegebene Anzahl sicherer Zufallsbytes (Hex-encoded)
	\item \texttt{hashPassword(\$username, \$pw)} -- Berechnet den Passwort-Hash, siehe Abschnitt \fullref{sec:pwhash}
	\item \texttt{class DB} -- Die DB-Klasse kapselt Datenbankzugriffe über ein Singleton.
	\begin{itemize}
		\item Die Felder connection, statement und error sind zwecks leichtem Zugriff public.
		\item \texttt{query(...)} führt eine Datenbankabfrage (mit Längenprüfung der Parameter) durch. Die Felder statement und ggf. error werden gesetzt.
		\item \texttt{get()} liefert die Singleton-Instanz
		\item \texttt{cleanup()} löscht veraltete Daten und wird automatisch beim Erstellen einer neuen Instanz aufgerufen
	\end{itemize}
	\item \texttt{getUser(...)} -- Wenn in den POST-Variablen ein gültiges Login (inkl. Clickjacking-Schutz) liegt, wird der dazugehörige User mit allen Daten zurückgegeben.
								Hier wird auch die Beschränkung der Fehlversuche pro IP und das Logging von Fehlversuchen durchgeführt.
								Zugriffe auf Benutzerdaten erfolgen über den Rückgabewert dieser Funktion, um sicherzustellen, dass immer ein Login erforderlich ist.
	\item \texttt{printLoginFields()} -- Gibt Felder für ein Loginformular inkl. Clickjacking-Schutz aus (die mit getUser() kompatibel sind)
	\item \texttt{checkPassword(...)} -- Prüft, ob ein Passwort inkl. Wiederholung in Ordnung sind, d.h. das Passwort setzt werden kann.
										Prüft \textbf{nicht} ob ein Login gültig ist, dafür ist getUser da!
	\item \texttt{checkMail(...)} -- Prüft, ob eine E-Mail-Adresse gültig und noch nicht verwendet (d.h. für das Anlegen eines Accounts zulässig) ist
\end{itemize}

\subsubsection{/includes/tokenimport.inc.php}
Diese Datei wird weder vom Rest des Codes genutzt, noch nutzt sie andere Teile des Codes.
Sie enthält eine Funktion (PiratenIDImport\_import) zum Import von Token-Daten.
Eine genaue Beschreibung ist in der Datei enthalten.

\subsubsection{/includes/.htaccess}
Diese Datei verhindert direkten Zugriff auf die Include-Files.



\subsection{Verzeichnis /user/}
Dieses Verzeichnis enthält Seiten, die mit der Verwaltung der Benutzerkonten zusammenhängen.

\subsubsection{/user/create.php}
Diese Datei regelt die Erstellung von Benutzerkonten.
Sie zeigt das entsprechende Formular an, nimmt die Daten entgegen, prüft sie, trägt den Nutzer in der Datenbank ein und versendet die Aktivierungsmail.

\subsubsection{/user/confirm.php}
Diese Datei regelt die Bestätigung der Mailadresse/Aktivierung der Benutzerkonten.
Sie wird ausschließlich über einen Link aus der Aktivierungsmail aufgerufen und erhält den Aktivierungsschlüssel.
Daraufhin versucht sie die Datenbank entsprechend zu aktualisieren und teilt dem Nutzer das Ergebnis mit.
Im Erfolgsfall wird (mit einem Link auf entertoken.php) darauf hingewiesen, dass der Nutzer jetzt sein Token eintragen soll.

\subsubsection{/user/entertoken.php}
Diese Datei ermöglicht es dem Nutzer, seinem Account ein Token hinzuzufügen.
Sie zeigt das entsprechende Formular an, nimmt die Daten entgegen, prüft sie und trägt die Änderung in der Datenbank ein.

\subsubsection{/user/changepw.php}
Diese Datei ermöglicht es dem Nutzer, sein Kennwort zu ändern.
Sie zeigt das entsprechende Formular an, nimmt die Daten entgegen, prüft sie und trägt die Änderung in der Datenbank ein.

\subsubsection{/user/requestreset.php}
Diese Datei ermöglicht es dem Nutzer, eine Passwortreset-Mail anzufordern.
Sie zeigt das entsprechende Formular an, nimmt die Daten entgegen, prüft sie, erstellt ggf. ein Token und trägt es in die Datenbank ein und verschickt die Mail mit dem Link.

\subsubsection{/user/doreset.php}
Diese Datei ermöglicht es dem Nutzer, sein Kennwort über einen via requestreset.php angeforderten Link zurückzusetzen.
Sie gibt ein Formular zur Eingabe eines neuen Kennworts aus, nimmt die Daten entgegen, prüft das Token und die Daten und ändert ggf. das Kennwort.

\subsubsection{/user/requestdelete.php}
Diese Datei ermöglicht es dem Nutzer, die Löschung eines Benutzerkontos zu beantragen.
Der Nutzer muss die Löschung durch Eingabe des Wortes LOESCHEN bestätigen.
Sie zeigt das entsprechende Formular an, nimmt die Daten entgegen, und prüft sie.
Im Erfolgsfall wird ein Löschtoken erzeugt, in die Datenbank eingetragen und eine Mail mit dem Bestätigungslink verschickt.

\subsubsection{/user/dodelete.php}
Diese Datei ermöglicht es dem Nutzer, sein Benutzerkonto über einen via requestdelete.php angeforderten Link zu löschen.
Es wird zwischen Accounts mit und Accounts ohne Token(hash) unterschieden. Accounts ohne Token(hash) werden sofort gelöscht.
Bei Accounts mit eingetragenem Token werden bis auf Token(hash), Usersecret, E-Mail-Verifizierungsstatus und Erstellungsdatum
alle Daten überschrieben.
Der Tokenhash bleibt gespeichert, damit das Token nicht wiederverwendet werden kann.
Das Usersecret bleibt gespeichert um z. B. bei missbräuchlicher Löschung gehackter Accounts den Account wiederherstellen zu können.
Der Verifizierungsstatus (immer true) bleibt gespeichert, da nicht verifizierte Konten aus der Datenbank entfernt werden - das darf bei eingetragenem Token nicht geschehen.
Der Benutzername wird durch einen zufällig generierten Benutzernamen ersetzt.

\subsection{Verzeichnis /openid/}
Dieses Verzeichnis enthält die serverseitige Implementierung des OpenID-Teils

\subsubsection{/openid/endpoint.php}
Der OpenID-Endpoint, das Herzstück des Systems.
Behandelt den Authentifizierungsvorgang:

\begin{itemize}
	\item OpenID-Requests von Webanwendungen
	\item Login durch den Nutzer
	\item Antwort auf die OpenID-Anfrage
	\item Bestätigen der OpenID-Daten gegenüber der Webanwendung
\end{itemize}

Der Großteil der Datei besteht aus Funktionsdefinitionen.
Am Ende wird entschieden, was für eine Anfrage vorliegt, und entsprechend die passende Funktion aufgerufen.
Die einzelnen Funktionen sind innerhalb der Datei kommentiert, nur die wichtigsten werden hier aufgeführt,
in der Reihenfolge, in der sie in einem normalen Authentifizierungsvorgang eine Rolle spielen.

\begin{itemize}
	\item \texttt{getOpenIDFields} -- liest die OpenID-Werte aus der GET- oder POST-Anfrage aus. Umgeht dabei ein PHP-"`Feature"', welches Feldnamen umbenennt.
	\item \texttt{evaluateFields} -- prüft die übergebenen OpenID-Werte von Anfragen (wird von handleCheckidSetup und handleUserConfirm genutzt/aufgerufen)
	\item \texttt{handleCheckidSetup} -- liefert das Login-Formular, wenn eine OpenID-Authentifizerungsanfrage ankommt oder handleUserConfirm einen Fehler entdeckt.
	\item \texttt{handleUserConfirm} -- verarbeitet die Antwort auf das Login-Formular (d.h. die Bestätigung der Anfrage durch den Nutzer)
	\item \texttt{addAXAttributes} -- fügt einer von handleUserConfirm vorbereiteten OpenID-Antwort die zusätzlichen Attributfelder hinzu, falls nötig.
	\item \texttt{sendIndirectResponse} -- liefert eine HTML-Seite mit einer indirekten OpenID-Antwort (wird von handleUserConfirm aufgerufen)
											(d.h. einem HTML-Formular, welches an die anfragende Webanwendung zurückgePOSTed wird und die OpenID-Antwort enthält.
											Enthält eine Warnung, dass der Nutzer nun zur ursprünglichen Seite zurückkehrt,
											um Phishing z. B. durch das Anfordern von HTTP Basic Auth (während der Nutzer noch die ID-Seite sieht) zu verhindern.
	\item \texttt{handleCheckAuth} -- verarbeitet die Verifizierungsanfrage der Webanwendung (Prüfung der indirekten Antwort)
	\item \texttt{sendDirectResponse} -- beantwortet eine direkte OpenID-Anfrage (für die Überprüfung der übermittelten Daten, wird von handleCheckAuth aufgerufen)
\end{itemize}



\subsubsection{/openid/xrds.php}
Liefert ein XRDS-Dokument mit einem Verweis auf den OpenID-Endpoint aus.
Dies wird für die Verwendung mit normalen OpenID-Libraries benötigt.

\subsubsection{/openid/pseudonym.php}
Die Pseudonym-URLs verweisen auf diese Datei.
Liefert ein XRDS-Dokument aus, welches bestätigt, dass die Pseudonyme vom PiratenID-Endpoint authentifiziert werden.
Dies wird für die Verwendung mit normalen OpenID-Libraries benötigt.


\subsection{Verzeichnis /static/}
Dieses Verzeichnis enthält statische Dateien wie Grafiken, Stylesheets, die Sicherheits-Hinweisbanner etc.

\subsection{Verzeichnis /doc/}
In dieses Verzeichnis müssen bei der Installation die kompilierten PDF-Dateien der Dokumentation
(\textbf{idsystem-techdoc.pdf}, \textbf{idsystem-devdoc.pdf} und \textbf{idsystem-userdoc.pdf}) abgelegt werden.

\newpage
\section{Datenbank}
Ein SQL-Dump der Datenbankstruktur sollte dieser Dokumentation beiliegen.
Die Datenbank besteht aus drei Tabellen:

\subsection{Tabelle "`users"'}
Diese Tabelle enthält die Benutzerkonten. Folgende Felder sind vorhanden:
\begin{itemize}
	\item \texttt{username} -- der eindeutige, nicht änderbare Benutzername (Primärschlüssel)
	\item \texttt{usersecret} -- das Benutzer-Secret zur Berechnung der Pseudonyme (siehe Abschnitt \fullref{sec:pseudo})
	\item \texttt{pwhash} -- der Hash des Passworts (siehe Abschnitt \fullref{sec:pwhash})
	\item \texttt{email} -- die E-Mail-Adresse (z. B. für Passwortresets)
	\item \texttt{email\_activationkey} -- der Hash des Aktivierungsschlüssels zum Bestätigen der Mailadresse
	\item \texttt{email\_verified} -- gibt an, ob die Adresse bestätigt ist
	\item \texttt{token} -- das eingetragene Token (gehasht) -- darf nicht mehr verändert oder gelöscht werden!
	\item \texttt{mitgliedsnr} -- Feld zur Aufnahme der Mitgliedsnummer, sofern diese Funktion implementiert wird
	\item \texttt{realname} -- Feld zur Aufnahme des Realnamens, sofern diese Funktion implementiert wird
	\item \texttt{resettoken} -- Hash des Passwort-Reset-Tokens, falls verschickt (sonst NULL)
	\item \texttt{resettime} -- Zeitpunkt, zu dem die Resetmail verschickt wurde
	\item \texttt{deletetoken} -- Hash des Account-Lösch-Tokens, falls verschickt (sonst NULL)
	\item \texttt{deletetime} -- Zeitpunkt, zu dem die Mail mit dem Accountlöschtoken verschickt wurde
	\item \texttt{createtime} -- Zeitpunkt, zu dem der Account erstellt wurde
\end{itemize}


\subsection{Tabelle "`tokens"'}
Diese Tabelle enthält die Zuordnungen zwischen Token(hashes) und Verbandsmitgliedschaften.
Sie sollte regelmäßig geleert und neu aus der Mitgliederverwaltung importiert werden. (Siehe /includes/tokenimport.inc.php)
Folgende Felder sind vorhanden:
\begin{itemize}
	\item \texttt{token} -- Das (gehashte) Token (Primärschlüssel)
	\item \texttt{mitgliedschaft-bund}
	\item \texttt{mitgliedschaft-land}
	\item \texttt{mitgliedschaft-bezirk}
	\item \texttt{mitgliedschaft-kreis}
	\item \texttt{mitgliedschaft-ort}
	\item \texttt{stimmberechtigt}
\end{itemize}

Bezüglich der Bedeutung und möglicher Werte für die Mitgliedschaftsfelder sei auf Abschnitt \fullref{sec:attribute} verwiesen.

\subsection{Tabelle "`openid"'}
Diese Tabelle enthält die ausgegebenen Nonces der OpenID-Antworten inkl. der dazugehörigen Hashes.
Sie wird verwendet, um bei der Verifikationsanfrage die Echtheit jeder Antwort genau einmal zu bestätigen.
\begin{itemize}
	\item \texttt{nonce} -- Die Nonce aus der Antwort
	\item \texttt{hmac} -- Der authentifizierte Hash der OpenID-Antwort
	\item \texttt{createtime} -- Die Zeit der Antwort
\end{itemize}

\subsection{Tabellen "`loginfailures"' und "`loginfailures\_log"'}
Diese Tabellen speichern fehlgeschlagene Loginversuche.
Die Tabelle "`loginfailures\_log"' speichert diese Versuche vier Wochen lang, um langfristig angelegte Angriffe erkennen zu können.
Sie kann manuell oder durch zusätzliche Tools analysiert werden und wird vom Programm ansonsten nicht verwendet.
Es werden folgende Werte gespeichert:
\begin{itemize}
	\item \texttt{ip} -- Die IP, von der die Anfrage kam
	\item \texttt{timestamp} -- Die Uhrzeit, um die die Anfrage kam
	\item \texttt{useragent} -- Der bei der Loginanfrage mitgeschickte Referer-Header, formatiert mit logPrefilter
	\item \texttt{referer} -- Der bei der Loginanfrage mitgeschickte Referer-Header, formatiert mit logPrefilter
\end{itemize}
Die verwendeten Benutzernamen werden aus Datenschutzgründen bewusst nicht gespeichert.

Die Tabelle "`loginfailures"' speichert nur IP und Timestamp für die Dauer von 30 Minuten und wird für die IP-Sperre verwendet.

\newpage
\section{Client (PHP)}
\input{idsystem-clientdoc-shared}

\subsection{Dateien}
Der Client besteht aus folgenden Dateien:
\begin{itemize}
	\item \texttt{piratenid.php} --
		Die Client-Klasse selbst. Die Funktionen werden weiter unten beschrieben.
	\item \texttt{certificate.pem} -- 
		Das Zertifikat, über das der PiratenID-Server authentifiziert wird.
		Dabei kann es sich entweder um das Zertifikat des Servers selbst,
		oder um das einer CA (Zertifizierungsstelle) im Zertifikatspfad des Serverzertifikats handeln.
	\item \texttt{button-*.png} --
		Drei Grafiken für Login/Logout/Fehler-Buttons.
	\item \texttt{example.php} --
		Ein Beispiel für die Verwendung des OpenID-Clients. Nicht Teil des eigentlichen Clients, sollte nicht in die Produktivumgebung kopiert werden.
\end{itemize}

\subsection{Funktionen}
Die Funktionen sind in der PiratenID-Klasse kommentiert. Fett gedruckte Funktionen sind public.
\begin{itemize}
	\item \textbf{\texttt{run()}} --
		Automatisiert alle relevanten Abläufe, siehe Abschnitt \fullref{sec:client-usage-basic}.
		Eine Session wird gestartet, OpenID-Antworten und Logout-Wünsche werden bearbeitet.
	\item \texttt{error(...)} --
		Setzt die \$error-Variable und gibt den HTML-Code für einen Fehlerbutton zurück. Wird von \texttt{run()} genutzt.
	\item \textbf{\texttt{autoButton(...)}} --
		Liefert je nach Login-Status den passenden Button (Login oder Logout) zurück. Initialisiert die Session, falls nötig.
	\item \textbf{\texttt{button(...)}} --
		Liefert den HTML-Code für einen Button zurück, welcher auf eine passende URL (Login/Logout etc.) verweist.
	\item \textbf{\texttt{logout()}} --
		Loggt den Benutzer aus. Initialisiert die Session, falls nötig.
	\item \textbf{\texttt{initSession()}} --
		Initialisiert die Session und wendet dabei erweiterte Sicherheitsmaßnahmen an.
	\item \textbf{\texttt{handle()}} --
		Wertet eine OpenID-Antwort aus (inkl. Verifizierung via \texttt{checkSignature(...)}) und gibt das Ergebnis zurück.
		Siehe auch Abschnitt  \fullref{sec:client-usage-advanced}.
	\item \textbf{\texttt{makeOpenIDURL()}} --
		Liefert eine URL zum OpenID-Endpoint, welche eine Login-Anfrage mit den aktuellen Parametern enthält.
		Sollte nicht verwendet werden, da die URLs bei vielen Parametern sehr lang werden und Probleme verursachen können.
	\item \textbf{\texttt{PiratenID::buildFormHTML(\$targeturl, \$fields, \$imgurl, \$title, \$method)}} --
		Liefert den HTML-Code für ein Formular mit grafischem Absendebutton mit den genannten Parametern.
		Siehe auch Abschnitt  \fullref{sec:client-usage-advanced}.
	\item \textbf{\texttt{getOpenIDRequest()}} --
		Liefert die OpenID-Felder für eine Login-Anfrage mit den aktuellen Parametern.
		Siehe auch Abschnitt  \fullref{sec:client-usage-advanced}.
	\item \texttt{initParams()} --
		Prüft und initialisiert die Parameter, errechnet abgeleitete Defaultwerte.
		Wird von den meisten Funktionen, die Parameter nutzen, aufgerufen.
	\item \textbf{\texttt{isSSL()}} --
		Gibt eine Vermutung darüber ab, ob die Seite über eine SSL-Verbindung aufgerufen wird.
	\item \texttt{checkSignature(...)} --
		Prüft die Signatur einer OpenID-Antwort durch SSL-gesicherte Rückfrage beim Endpoint.
	\item \texttt{getOpenIDFields(...)} -- 
		Liest die OpenID-Werte aus einer GET- oder POST-Anfrage aus. Umgeht dabei ein PHP-"`Feature"', welches Feldnamen umbenennt.
	\item \texttt{isValidKeyValue(...)} -- 
		Prüft, ob das übergebene Paar gültige Werte für einen OpenID-Feldnamen und --wert beinhaltet.
\end{itemize}

\subsection{Interner Betrieb}
Wird der Client auf einem Host innerhalb des internen Netzes eingesetzt, kann er den Server nicht unter der normalen URL erreichen.
Daher kann über die Konstante \texttt{INTERNAL\_endpoint} eine alternative URL genannt werden, die nur für den Verbindungsaufbau genutzt wird.

Um sicherzustellen, dass eine derart modifizierte Variante des Clients nicht versehentlich auf Systeme außerhalb des internen Netzes kopiert wird,
muss gleichzeitig auch der Hostname des Systems in die Konstante \texttt{INTERNAL\_host} eingetragen werden, damit die Konstante verwendet wird.
Ist ein falscher Hostname eingetragen, bricht der Client die Verifizierung von OpenID-Antworten ab.
Dadurch wird verhindert, dass eine für den internen Einsatz gedachte URL ohne HTTPS versehentlich auf externen Servern verwendet wird.

\subsection{Schutzmaßnahmen}
Besondere Schutzmaßnahmen im Client werden in Abschnitt \fullref{sec:security-client} erläutert.

\end{document}




